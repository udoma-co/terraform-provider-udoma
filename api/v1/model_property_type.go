/*
Udoma

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v1

import (
	"encoding/json"
	"fmt"
)

// PropertyType the model 'PropertyType'
type PropertyType string

// List of PropertyType
const (
	PROPERTYTYPE_APARTMENT          PropertyType = "APARTMENT"
	PROPERTYTYPE_ATTIC              PropertyType = "ATTIC"
	PROPERTYTYPE_BASEMENT           PropertyType = "BASEMENT"
	PROPERTYTYPE_BUILDING           PropertyType = "BUILDING"
	PROPERTYTYPE_COMMERCIAL_SPACE   PropertyType = "COMMERCIAL_SPACE"
	PROPERTYTYPE_GARAGE             PropertyType = "GARAGE"
	PROPERTYTYPE_GARDEN             PropertyType = "GARDEN"
	PROPERTYTYPE_HOUSE              PropertyType = "HOUSE"
	PROPERTYTYPE_LAND               PropertyType = "LAND"
	PROPERTYTYPE_OFFICE             PropertyType = "OFFICE"
	PROPERTYTYPE_PARKING_LOT        PropertyType = "PARKING_LOT"
	PROPERTYTYPE_ROOM               PropertyType = "ROOM"
	PROPERTYTYPE_SEMIDETACHED_HOUSE PropertyType = "SEMIDETACHED_HOUSE"
	PROPERTYTYPE_OTHER              PropertyType = "OTHER"
)

// All allowed values of PropertyType enum
var AllowedPropertyTypeEnumValues = []PropertyType{
	"APARTMENT",
	"ATTIC",
	"BASEMENT",
	"BUILDING",
	"COMMERCIAL_SPACE",
	"GARAGE",
	"GARDEN",
	"HOUSE",
	"LAND",
	"OFFICE",
	"PARKING_LOT",
	"ROOM",
	"SEMIDETACHED_HOUSE",
	"OTHER",
}

func (v *PropertyType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := PropertyType(value)
	for _, existing := range AllowedPropertyTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid PropertyType", value)
}

// NewPropertyTypeFromValue returns a pointer to a valid PropertyType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewPropertyTypeFromValue(v string) (*PropertyType, error) {
	ev := PropertyType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for PropertyType: valid values are %v", v, AllowedPropertyTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v PropertyType) IsValid() bool {
	for _, existing := range AllowedPropertyTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to PropertyType value
func (v PropertyType) Ptr() *PropertyType {
	return &v
}

type NullablePropertyType struct {
	value *PropertyType
	isSet bool
}

func (v NullablePropertyType) Get() *PropertyType {
	return v.value
}

func (v *NullablePropertyType) Set(val *PropertyType) {
	v.value = val
	v.isSet = true
}

func (v NullablePropertyType) IsSet() bool {
	return v.isSet
}

func (v *NullablePropertyType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePropertyType(val *PropertyType) *NullablePropertyType {
	return &NullablePropertyType{value: val, isSet: true}
}

func (v NullablePropertyType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePropertyType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
